Vi parsar hela filen medans de parsar bara den delen som behövs för uppgiften
regex patterns har onödiga delar. Ex ta bort onödiga /m flaggor samt byta ut ^\s mot \S


Markus: Hur koden funkar
Uppgift 1

main funktion flera hjälp, generella funktioner

löser båda uppgifterna med samma mönster

börjar med 
läsa in och delvis parsa fil
getTextFromTag:  Matchar allt mellan <pre> och </pre>

separat funktion beroende på weather eller football

sedan kallar på
sortByDifference: sorterar arrayen

många regex matchningar
vissa kunte göras enklare. Ta bort onödiga flaggor

parsar inte hela filen

SAX:
snygg lösning
kunde gjorts minimalt enklare
sparar i en hash
sparar en "stack" / "path"

tag_start
gör många jämförelser med "tagname" ist för att lägga till i path och bara använda den

tag_end
tar bort senaste entryn i path


DOM
ochså snygg lösning
Ganska bra XPATH filtrering.
Funkar bra för denna fil
Kunde göras mer specifik fört att undvika eventuella fel i framtiden 


SKRIV UT!!!!!!
/(\d*)\s+-\s (\d*)/m 

/(\d+)\s+-\s+(\d+)/
----------------------------------------
/catalogue/entryLinks/*[count(@hidden)=0]

/catalogue/entryLinks/entryLink[count(@hidden)=0]

-||- [not(@hidden)]
----------------------------------------
//selectionEntry


----------------------------------------

Vadym: Hur det är jämfört med vår

Uppg1: ---------------------------------
Vi tog annorlunda approaches gällande data-parsing:
De parsade endast dem delar som användes i uppgifter
(dvs F och A kolumner för football och första fyra kolumner för weather)
Vi parsade allt data som fanns

För att parsa data:
De använde sig mycket av regex
Vi använde oss av regex men också split och indexering i strings

Uppg2: ---------------------------------
Vi använde samma metod för att hålla koll på
var i XML vi befinner oss - en stack struktur 
(path och stack)

Vi sparade också unit_prices i en Hash och sparade sista unit_name i en variabel

Vi använde oss av 0 som placeholder price istället för nil 
(de kunde enklare testa att det finns pris för alla units)

DOM parser var också strukturerad likadant ut förutom tidigare nämnt XPath optimeringar

------------------------------------------------------------

Markus: Tekniker i kod

------------------------------------------------------------

Vadym: Kodningstil, tester och utvecklarblogg

Kodningstil:
uppg1 och uppg2 DOM använder sig av 'camelCase' fast uppg2 SAX använder sig av 'snake_case'
testerna för uppg1 använder sig av 'test_functionName' (även 'test_FunctionName')
och testerna för uppg2 använder sig av 'test_function_name' 
även om function_name i originalfilen är skriven med 'camelCase'
Det ser ut att den gruppen kom inte överens om kodningstil alls.

Funktionsnamn och variablesnamn var till den största delen är bra
De hade för många kommentarer och mest av dem är onödiga

Tester:
Testerna var relativt bra för att de testade alla funktioner, men var inte tillräckligt täckande. 
T.ex i uppg1 kontrollerar de endast första och sista entries i listan, men inte allt som står emellan.
De har inte heller testat med andra filler än det som gavs i uppgiften - 
dvs de testade inte att deras kod fungerar för andra filer av liknande struktur.

Utvecklarblogg:
Deras utvecklarblogg är uppbugd som en dagbok med förklaring av kod, och tar inte upp:
reflektioner kring lärondemoment, Rube, själva uppgifter eller tolkningar av uppgifter.
